---
title: "High level designs V/S Low level designs"
description: "High level designs V/S Low level designs in system designs. This blog is the basic overview educating about the difference between low level designs and high level designs "
image: "../../public/blogs/art-28.webp"
publishedAt: "2024-09-28"
updatedAt: "2024-09-28"
author: "amaanbhati"
isPublished: true
tags:
- system-design
- tools
---


# High-Level Designs vs Low-Level Designs in System Design


## Introduction

System design plays a pivotal role in the development of software applications, especially as systems become more complex. To manage this complexity, the design process is typically divided into two key stages: High-Level Design (HLD) and Low-Level Design (LLD). While these terms might seem technical, they simply represent the level of detail included at each phase.

> HLD focuses on the overall system architecture, offering a broad view of how different components interact and what technologies will be used. It provides a general description of how the system is structured. In contrast, LLD delves deeper, outlining the specific details of each system component and how they function together. It’s the phase where each module, its internal workings, and the relationships between them are fully defined.

In this blog, we'll dive deeper into both HLD and LLD, clarifying their roles, importance, and how they differ from each other. By the end, you'll have a clear understanding of how these two stages complement one another to create systems that are scalable, maintainable, and efficient.

## What is High-Level Design?

> High-Level Design (HLD) is a top-level representation of the overall system architecture and serves as the blueprint for the system as a whole. It provides a broad view of the system’s major components and their interactions, without going into the implementation details. 

Essentially, HLD acts as a bridge between the business requirements and the technical design of the system. It’s created early in the system design process, allowing stakeholders and engineers to align on the system’s architecture and high-level goals.

### Key Aspects of HLD:
- **System Overview**: HLD defines the overall system architecture, identifying the key components or modules that will make up the system. Each of these components will be further broken down in the LLD phase. HLD provides an architectural overview of the system, breaking it down into key modules, subsystems, and components. It outlines how these components will interact and communicate to meet the system’s goals.
  
- **Component Interaction**: In HLD, the focus is on how the different parts of the system will communicate with each other. This might include how user inputs travel through the system, how data flows between different modules, and how external systems (like APIs) are integrated.

- **Technology Stack**: HLD outlines the technologies that will be used in the system. This includes everything from the programming languages (e.g., JavaScript, Python) to the databases (e.g., MySQL, MongoDB), servers (e.g., Node.js, Nginx), and third-party services (e.g., payment gateways).

- **System Boundaries**: It is important to define where the system starts and ends. HLD helps to identify **external systems** that interact with the application, such as third-party APIs, external databases, or user devices.

- **Architectural Patterns**: In HLD, you decide on the architectural style of the system. Common patterns include **Monolithic**, **Microservices**, and **Serverless** architectures. Each pattern has its pros and cons, and HLD gives you the flexibility to choose the right one based on your project's needs.

- **Security Requirements**: At a high level, HLD addresses security concerns. For example, it might outline general approaches to securing user data (e.g., encryption, secure communication protocols) without going into implementation details.

- **Diagrams**: Visual representations, such as **component diagrams**, **data flow diagrams**, and **architecture diagrams**, are a fundamental part of HLD. These diagrams help in visualizing how the system will function from a high-level perspective, showing the relationships between components, databases, and external systems.

- **Database Design**: HLD includes a high-level representation of the system's data structure and storage strategy. While it doesn’t go into specifics like exact schemas, it does show how data flows between different components and where it will be stored.


### Example of HLD: E-Commerce Platform

Let’s imagine you’re building an **e-commerce platform**. The High-Level Design (HLD) for such a system would provide a top-level view of the key components, their interactions, and the overall system architecture. The following is an example breakdown of what an HLD might look like for this platform:

#### Major Components

- **Frontend**: 
  This is the user-facing interface where customers interact with the platform. It includes pages for browsing products, viewing product details, managing shopping carts, and completing orders. The frontend typically consists of:
  - **User Interface (UI)**: Built using web technologies like React, Vue.js, or Angular for smooth and responsive user experiences.
  - **Responsive Design**: Ensures the platform is accessible across devices (mobile, tablet, desktop).
  - **Communication**: The frontend communicates with the backend through REST APIs or GraphQL, sending requests for product data, managing user sessions, etc.

- **Backend**:
  The backend handles the core business logic of the platform. It processes user requests, manages the system's internal workflows, and interacts with databases. The backend typically includes:
  - **Application Logic**: Written in server-side languages such as Node.js, Python, or Java, it manages operations like user authentication, order processing, and product management.
  - **APIs**: Exposes endpoints for frontend interaction, enabling features like fetching product data, adding items to the cart, and placing orders.
  - **Microservices Architecture** (optional): In a more scalable architecture, the backend may consist of multiple microservices, each responsible for a specific functionality (e.g., product catalog, order management, user authentication).

- **Database**:
  The database stores all critical data for the platform. This includes user details, product listings, order history, and payment transactions. Depending on the scale and requirements, different types of databases may be used:
  - **Relational Database**: A traditional RDBMS like MySQL or PostgreSQL can be used to store structured data, such as customer profiles, product descriptions, and orders.
  - **NoSQL Database**: A NoSQL database like MongoDB or Cassandra might be used for storing product catalogs or user-generated data like reviews and search histories, where flexible schemas and high availability are important.
  - **Data Flow**: The backend interacts with the database through queries, fetching data for the frontend and storing new data as users interact with the platform.

- **Payment Gateway**:
  To process payments, the platform integrates with third-party payment processors like **Stripe**, **PayPal**, or **Square**. The HLD includes how this integration works:
  - **Payment Flow**: The platform sends transaction details to the payment gateway. The user completes the payment securely through the gateway’s interface, which then sends confirmation back to the backend.
  - **Security**: Payment transactions are secured using SSL/TLS encryption, and sensitive data like credit card details are never stored directly on the platform’s servers.

#### Communication and Interactions Between Components

In the HLD, you would also describe how these major components communicate with each other. For example:

- **Frontend-Backend Interaction**: 
  The frontend sends HTTP requests to the backend to retrieve product details, handle login sessions, and manage user orders. This communication happens through a REST API or GraphQL endpoints exposed by the backend. WebSockets might also be used for real-time updates (e.g., stock availability).

- **Backend-Database Interaction**:
  The backend queries the database to fetch products, validate user credentials, and process orders. It also updates the database when an order is placed, or user details are modified. This interaction might involve transaction handling to ensure data integrity, especially for critical operations like payments.

- **Backend-Payment Gateway Integration**:
  When a user makes a purchase, the backend sends transaction details to the payment gateway through a secure API call. The payment gateway processes the payment and responds with a success or failure message, which the backend uses to confirm or reject the order.

#### Technologies Involved

The HLD would also detail the **technology stack** to be used. For instance:

- **Frontend**: React.js for the user interface, Next.js for server-side rendering (SSR), and Tailwind CSS for styling.
- **Backend**: Node.js with Express for handling API requests, or a microservices architecture using Docker and Kubernetes for container orchestration.
- **Database**: PostgreSQL for relational data and Redis for caching frequently accessed data (like product listings).
- **Payment Gateway**: Integration with Stripe’s API to securely process transactions.
- **Cloud Infrastructure**: The entire platform may be hosted on cloud services like AWS or GCP, with services like S3 for object storage, RDS for database management, and EC2 for scalable computing.

#### External Services

In an HLD, it’s important to outline any external services the platform depends on. For this e-commerce platform, external services might include:

- **CDN**: A content delivery network like Cloudflare or AWS CloudFront to ensure fast loading times for users by caching static assets like images, CSS, and JavaScript files.
- **Email Service**: An external email service like SendGrid or Amazon SES to send transactional emails (e.g., order confirmations, password resets) to customers.
- **Logging and Monitoring**: Services like Datadog or AWS CloudWatch to monitor the system’s health, log errors, and alert engineers in case of failures.

---

### Summary of E-Commerce Platform HLD

The High-Level Design (HLD) of an e-commerce platform breaks down the major components (frontend, backend, database, payment gateway) and explains how they interact. By documenting the system architecture, key interactions, and external dependencies, the HLD provides a complete overview of the platform's structure and the technologies involved, ensuring all stakeholders understand how the system is expected to function at a high level.


  
You would then explain how these components communicate, what technologies you’re using, and any external services involved.

## What is Low-Level Design (LLD)?

> **Low-Level Design (LLD)**, also known as **detailed design**, dives into the inner workings of the system. It translates the abstract view provided by the High-Level Design (HLD) into a concrete and detailed blueprint for developers. While HLD outlines the overall architecture and main components of the system, LLD focuses on the specifics of how each component will be implemented. It defines the technical intricacies and guides developers on exactly **how** to build and integrate each part of the system.

At this stage, you’re no longer working on abstract concepts — you’re defining the **precise details**, including classes, methods, interactions between components, and data handling mechanisms.

### Key Aspects of LLD

####  Component Breakdown
LLD decomposes the larger components from the HLD into smaller, more manageable pieces, each with specific responsibilities.

- **Backend Example**: In the HLD, you may have outlined a general "Backend" component. In LLD, this would be broken down further into **classes** or **modules** that each serve specific functions:
  - **Authentication Module**: Manages user login, registration, and session handling.
  - **Product Management Module**: Handles CRUD (Create, Read, Update, Delete) operations for product listings.
  - **Order Processing Module**: Manages order placement, inventory updates, and communication with the payment system.
  - **Payment Processing Module**: Integrates with third-party services to handle payments.

####  Class Diagrams
Class diagrams are a critical part of LLD. They visually represent the structure of the system, including:
  
- **Classes and Objects**: Each class in the system (e.g., `User`, `Product`, `Order`) is detailed in terms of its **attributes** (e.g., `username`, `password`, `price`, `quantity`) and **methods** (e.g., `login()`, `addProduct()`, `checkout()`).
- **Relationships**: Class diagrams show how different classes relate to each other (e.g., a **`User`** can have multiple **`Orders`**; an **`Order`** contains multiple **`Products`**).
- **Inheritance and Interfaces**: They also highlight any inheritance relationships (e.g., a **`RegisteredUser`** might inherit from a **`User`** class), and how different components communicate through interfaces.

####  Sequence Diagrams
Sequence diagrams show **step-by-step interactions** between components or modules over time. They help clarify how data moves through the system and illustrate the dynamic behavior of the system.

- **Example**: Imagine a user places an order on an e-commerce platform. A sequence diagram might show the following interactions:
  1. The **Frontend** sends an order request to the **Order Processing Module** in the **Backend**.
  2. The **Order Processing Module** validates the request and checks inventory.
  3. If inventory is sufficient, the **Payment Processing Module** contacts the **Payment Gateway** to process payment.
  4. Once payment is confirmed, the order is finalized and saved in the **Database**.
  
This shows how multiple components interact with each other in a time-sequenced manner.

####  Data Structures & Algorithms
LLD defines the specific **data structures** and **algorithms** that will be used within the system. These decisions affect how efficiently data is stored, retrieved, and processed.

- **Data Structures**: Depending on the use case, LLD might specify using **arrays**, **linked lists**, **hash maps**, or **trees**. For example:
  - **Hash maps** for efficient lookup of user session data.
  - **Linked lists** for managing an order history that users can navigate.
  
- **Algorithms**: LLD also defines the algorithms for key operations. For example:
  - **Search algorithms** for finding products based on user input.
  - **Sorting algorithms** to display products in order of price, popularity, or other criteria.

####  API Design
LLD specifies the exact **API endpoints** that will be exposed and their functionality, including details such as:

- **Endpoint URLs**: E.g., `/login`, `/products/:id`, `/checkout`.
- **HTTP Methods**: Which methods will be used for each endpoint (e.g., **GET**, **POST**, **PUT**, **DELETE**).
- **Request and Response Formats**: Defines the **input/output** data structures, typically in **JSON** or **XML** format. For instance, the `/products` endpoint might return a list of products in JSON format with fields like `id`, `name`, `price`, and `category`.

####  Error Handling & Edge Cases
LLD is meticulous about defining how the system should handle potential **errors** and **edge cases**, which ensures the system’s reliability and robustness.

- **Example Error Handling**:
  - What happens if the payment gateway is down?
  - How should the system respond if the user enters invalid credentials during login?
  
- **Edge Cases**: This includes planning for less common scenarios, like:
  - What if a product is added to the cart, but by the time the user checks out, it’s out of stock?
  - What if an API request times out?

By thinking through and planning for these cases in LLD, developers can prevent system crashes and improve user experience.

#### Database Schema
While HLD gives a high-level overview of the database, LLD goes into the specifics of the **database schema**, including:

- **Tables and Fields**: Detailed descriptions of the tables and fields, including their data types (e.g., `VARCHAR` for usernames, `INTEGER` for quantities, `DECIMAL` for prices).
- **Relationships**: For example, a **`Users`** table might have a one-to-many relationship with the **`Orders`** table, and the **`Orders`** table might have a many-to-many relationship with the **`Products`** table.
- **Indexes**: LLD might specify **indexes** on commonly queried fields (e.g., indexing the `email` field in the `Users` table) to speed up database queries.

####  Optimizations
LLD focuses on **performance optimizations** at a granular level. This is where strategies to make the system more efficient are defined, such as:

- **Caching**: Caching frequent API responses (e.g., popular products) to reduce database load.
- **Database Query Optimization**: Writing efficient SQL queries, adding indexes to frequently accessed tables, or partitioning large tables to improve performance.
- **Load Balancing**: Implementing load balancers to distribute traffic across multiple servers, ensuring the system can handle high volumes of requests.

---

### Summary

Low-Level Design (LLD) takes the broad concepts outlined in High-Level Design (HLD) and breaks them down into detailed, specific instructions for developers. It covers everything from data structures, class diagrams, and sequence diagrams to API design, error handling, and database schemas. LLD ensures that every part of the system is thoroughly planned, leaving no ambiguity for developers and making the system more robust, scalable, and efficient.



## Key Differences Between HLD and LLD

| Aspect                        | High-Level Design (MACRO LEVEL)                                         | Low-Level Design (MICRO LEVEL)                                                |
|-------------------------------|-----------------------------------------------------------------|----------------------------------------------------------------------|
| **Scope**                      | Overall system architecture and component interactions          | Detailed design of individual components and their internal workings  |
| **Focus**                      | System modules, technologies, and high-level interactions       | Data flow, class diagrams, algorithms, and low-level logic            |
| **Audience**                   | Stakeholders, architects, and project managers                  | Engineers and developers                                              |
| **Technology**                 | Technology stack and external services                          | Code structures, data models, and database schemas                    |
| **Security**                   | General security strategies                                     | Detailed authentication, authorization, and error-handling mechanisms |
| **Design Artifacts**           | Component diagrams, data flow diagrams                          | Class diagrams, sequence diagrams, database schema, API specs         |
| **Implementation Details**     | Abstract, no implementation specifics                           | Detailed code structure, logic, and data handling                     |
| **Performance Considerations** | High-level, general performance requirements                    | Detailed optimizations like caching, database indexes, and query tuning |
| **Tools Used**                 | Architecture tools like Lucidchart, Draw.io                      | UML tools, IDEs for code structure, and database schema design tools  |

## Conclusion

Both **High-Level Design (HLD)** and **Low-Level Design (LLD)** are crucial steps in the system design process. HLD provides the foundation by defining the system’s architecture, components, and overall interactions. Meanwhile, LLD builds on this foundation, giving developers the specific details they need to implement each part of the system correctly and efficiently.
